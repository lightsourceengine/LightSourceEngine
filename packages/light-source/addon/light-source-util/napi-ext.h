/*
 * Copyright (C) 2019 Daniel Anderson
 *
 * This source code is licensed under the MIT license found in the LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <napi.h>
#include <unordered_set>
#include <fmt/format.h>

namespace Napi {

/**
 * Creates a Symbol from a string key using javascript's Symbol.for().
 *
 * @throws Napi::Error generated by accessing the javascript context
 */
Symbol SymbolFor(Napi::Env env, const char* key);

/**
 * Looks up a property in a javascript Object, returning it's std::String value.
 *
 * @throws Napi::Error if key does not exist in object or keyed property is not a String
 */
std::string ObjectGetString(const Object& object, const char* key);

/**
 * Looks up a property in a javascript Object, returning it's std::String value. If no property exists for key, an
 * empty std::string is returned.
 *
 * @throws Napi::Error generated by accessing the javascript context
 */
std::string ObjectGetStringOrEmpty(const Object& object, const char* key);

/**
 * Looks up a property in a javascript Object, returning it's number value. If no property exists for key, defaultValue
 * is returned.
 *
 * @tparam T an integer or floating point type supported by Napi::Number.
 * @throws Napi::Error generated by accessing the javascript context
 */
template<typename T>
T ObjectGetNumberOrDefault(const Object& object, const char* key, T defaultValue);

/**
 * Handles the details of executing native code in a worker thread (Node's libuv thread pool) and handling the
 * result in the main event loop.
 *
 * Note, this is a specialization of AsyncWorker that provides an interface that is easier for light-source to
 * schedule async native work.
 */
template<typename T>
class AsyncTask {
 public:
    typedef std::function<std::shared_ptr<T> (Napi::Env)> ExecuteFunction;
    typedef std::function<void(Napi::Env, std::shared_ptr<T>, napi_status, const std::string&)> CompleteFunction;

 public:
    /**
     * Constructs a new async task.
     *
     * The task is immediately scheduled in Node's libuv thread pool. The task can be stopped by deleting this object.
     *
     * @param resourceName Name of this task used by Napi for internal tracking
     * @param execute Function called in a libuv thread. The javascript context should NOT be accessed in this callback.
     * The return value of execute is (thread) safely passed to complete. If an exception is thrown during execute,
     * complete receives the error information.
     * @param complete Function called after execute has completed. This callback runs on the main javascript thread,
     * where accessing the context is safe.
     * @throws Napi::Error if Napi async work cannot be created or queued
     * @throws Napi::Error generated by accessing the javascript context
     */
    AsyncTask(Napi::Env env, const std::string& resourceName, ExecuteFunction execute, CompleteFunction complete);
    ~AsyncTask();

 private:
    static void OnExecute(napi_env env, void* self);
    static void OnComplete(napi_env env, napi_status status, void* self);

 private:
    // XXX: Set that tracks active tasks (execute and complete have not been called). Used to guard against execute and
    //      complete callbacks running after AsyncTask has been deleted. Cancelling work or deleting work may not
    //      guarantee execute or complete will not be called (bug?).
    static std::unordered_set<AsyncTask<T>*> activeTasks;

    Env env;
    ExecuteFunction execute;
    CompleteFunction complete;
    napi_async_work work{};
    napi_status status{napi_ok};
    std::string message;
    std::shared_ptr<T> result;
};

} // namespace Napi

#include "napi-ext-inl.h"
